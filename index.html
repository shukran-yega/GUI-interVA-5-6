<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CCVA Processing</title>
  <style>
    * {
      box-sizing: border-box;
      font-family: "Segoe UI", Arial, sans-serif;
    }

    body {
      background-color: #f5f5f5;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      min-height: 100vh;
      padding: 40px 20px;
    }

    .main-wrapper {
      display: flex;
      gap: 20px;
      max-width: 1200px;
      width: 100%;
      align-items: flex-start;
    }

    .container {
      background: white;
      padding: 30px 40px;
      border-radius: 16px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      text-align: center;
      flex: 1;
      min-width: 600px;
    }

    .disclaimer-box {
      background: white;
      padding: 25px;
      border-radius: 16px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      width: 320px;
      text-align: left;
    }

    .disclaimer-box h2 {
      margin: 0 0 15px 0;
      font-size: 20px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
      color: #333;
    }

    .disclaimer-box .beta-badge {
      background: #007bff;
      color: white;
      padding: 3px 10px;
      border-radius: 12px;
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .disclaimer-box p {
      margin: 0 0 12px 0;
      font-size: 13px;
      line-height: 1.6;
      color: #555;
    }

    .disclaimer-box .version-info {
      background: #f8f9fa;
      border: 1px solid #e0e0e0;
      padding: 12px;
      border-radius: 8px;
      margin-top: 15px;
      font-size: 12px;
    }

    .disclaimer-box .version-info strong {
      display: block;
      margin-bottom: 6px;
      font-size: 13px;
      color: #333;
    }

    .disclaimer-box ul {
      margin: 8px 0 0 0;
      padding-left: 18px;
      color: #555;
    }

    .disclaimer-box li {
      margin-bottom: 4px;
      font-size: 12px;
    }

    @media (max-width: 1100px) {
      .main-wrapper {
        flex-direction: column;
      }
      
      .disclaimer-box {
        width: 100%;
        max-width: 600px;
      }
      
      .container {
        min-width: auto;
        width: 100%;
      }
    }

    h1 {
      margin: 0 0 15px 0;
      font-size: 24px;
      color: #333;
    }

    .file-info {
      margin-top: 8px;
      margin-bottom: 15px;
      font-size: 12px;
      color: #666;
      min-height: 18px;
      text-align: center;
    }

    .controls-row {
      display: flex;
      gap: 10px;
      width: 100%;
      align-items: center;
    }

    .file-input-wrapper {
      position: relative;
      flex: 1;
      min-width: 180px;
    }

    input[type="file"] {
      position: absolute;
      opacity: 0;
      width: 100%;
      height: 100%;
      cursor: pointer;
    }

    .file-button {
      background-color: #e8e8e8;
      border: 2px solid #bbb;
      border-radius: 8px;
      padding: 10px 16px;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s ease;
      white-space: nowrap;
      display: block;
      text-align: center;
      color: #555;
    }

    .file-input-wrapper:hover .file-button {
      border-color: #888;
      background-color: #dcdcdc;
    }

    button, select {
      background-color: #e8e8e8;
      border: none;
      border-radius: 8px;
      padding: 10px 16px;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s ease-in-out;
      white-space: nowrap;
    }

    select {
      flex: 1;
      min-width: 150px;
    }

    button {
      flex: 0 0 auto;
      min-width: 120px;
    }

    button:hover:not(:disabled), select:hover {
      background-color: #dcdcdc;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    #runBtn {
      background-color: #007bff;
      color: white;
      font-weight: 500;
    }

    #runBtn:hover:not(:disabled) {
      background-color: #0056b3;
    }

    #cancelBtn {
      background-color: #dc3545;
      color: white;
      font-weight: 500;
    }

    #cancelBtn:hover:not(:disabled) {
      background-color: #c82333;
    }

    .progress-section {
      margin-top: 15px;
      padding: 12px;
      background-color: #f8f9fa;
      border-radius: 10px;
      display: none;
    }

    .progress-section.active {
      display: block;
    }

    .progress-bar {
      width: 100%;
      height: 24px;
      background-color: #e0e0e0;
      border-radius: 12px;
      overflow: hidden;
      position: relative;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #007bff, #0056b3);
      transition: width 0.4s ease;
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 11px;
      font-weight: 600;
    }

    .progress-status {
      margin-top: 8px;
      font-size: 12px;
      color: #555;
      text-align: center;
    }

    .time-elapsed {
      margin-top: 6px;
      font-size: 11px;
      color: #777;
      text-align: center;
      font-family: 'Consolas', 'Monaco', monospace;
    }

    .output-box {
      margin-top: 15px;
      border: 1px solid #ddd;
      border-radius: 10px;
      height: 250px;
      padding: 12px;
      color: #777;
      font-size: 12px;
      line-height: 1.5;
      overflow-y: auto;
      text-align: left;
      background-color: #fafafa;
    }

    .output-box.success {
      border-color: #28a745;
      background-color: #f0f9f4;
    }

    .output-box.error {
      border-color: #dc3545;
      background-color: #fef5f5;
    }

    .download-link {
      margin-top: 12px;
      font-size: 13px;
      color: #007bff;
      text-decoration: none;
      cursor: pointer;
      display: none;
      padding: 10px 20px;
      background-color: #e7f3ff;
      border-radius: 8px;
      font-weight: 500;
      transition: all 0.2s ease;
    }

    .download-link.active {
      display: inline-block;
    }

    .download-link:hover {
      background-color: #cce5ff;
      color: #0056b3;
    }

    .log-message {
      padding: 4px 0;
      color: #555;
      font-size: 12px;
      font-family: 'Consolas', 'Monaco', monospace;
    }

    .log-message.success {
      color: #28a745;
    }

    .log-message.error {
      color: #dc3545;
    }

    .status-message {
      text-align: center;
      padding: 20px;
      color: #999;
      font-size: 13px;
    }

    .csmf-section {
      margin-top: 20px;
      padding: 20px;
      background: white;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
      display: none;
    }

    .csmf-section.active {
      display: block;
    }

    .csmf-section h3 {
      margin: 0 0 15px 0;
      font-size: 18px;
      color: #333;
      text-align: left;
    }

    .chart-container {
      position: relative;
      width: 100%;
      height: 400px;
      margin-top: 15px;
    }

    .bar-chart {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 10px 0;
    }

    .bar-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .bar-label {
      flex: 0 0 200px;
      text-align: right;
      font-size: 12px;
      color: #555;
      font-weight: 500;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .bar-wrapper {
      flex: 1;
      position: relative;
      height: 30px;
      background: #f0f0f0;
      border-radius: 4px;
      overflow: hidden;
    }

    .bar-fill {
      height: 100%;
      transition: width 0.8s ease-out;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      padding-right: 8px;
      border-radius: 4px;
    }

    .bar-value {
      font-size: 11px;
      font-weight: 600;
      color: white;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }

    .no-csmf-message {
      text-align: center;
      padding: 30px;
      color: #999;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div class="main-wrapper">
    <div class="container">
    <h1>CCVA Processing</h1>
    <div class="file-info" id="fileInfo">Select a CSV file to begin</div>

    <div class="controls-row">
      <div class="file-input-wrapper">
        <input type="file" id="fileInput" accept=".csv" />
        <div class="file-button" id="fileButton"> Choose CSV File</div>
      </div>
      
      <select id="whoVersionSelect">
        <option value="auto">Auto-detect WHO</option>
        <option value="2016WHOv151">WHO 2016</option>
        <option value="2022WHOv0101">WHO 2022</option>
      </select>
      
      <select id="algorithmSelect">
        <option value="InterVA-5">InterVA-5</option>
        <option value="InterVA-6">InterVA-6</option>
      </select>

      <button id="runBtn" disabled>Run Analysis</button>
      <button id="cancelBtn" disabled style="display: none;">Cancel</button>
    </div>

    <div class="progress-section" id="progressSection">
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill" style="width: 0%">
          <span id="progressPercent">0%</span>
        </div>
      </div>
      <div class="progress-status" id="progressStatus">Initializing...</div>
      <div class="time-elapsed" id="timeElapsed">‚è± Time: 0:00</div>
    </div>

    <div class="output-box" id="outputBox">
      <div class="status-message">Ready to process data</div>
    </div>

    <div class="action-row">
      
      <a class="download-link" id="downloadLink"> Download Results</a>
    </div>

    <div class="csmf-section" id="csmfSection">
      <h3>Cause specific mortality fraction for given population</h3>
      <div class="chart-container">
        <div class="bar-chart" id="barChart"></div>
      </div>
    </div>
  </div>

  <div class="disclaimer-box">
    <h2>
      Beta Version
      <span class="beta-badge">v1.0</span>
    </h2>
    
    <p><strong>Important Notice:</strong></p>
    
    <p>This is a beta version of the CCVA Processing System using InterVA algorithms. By using this platform, you acknowledge and agree to the following:</p>
    
    <p>‚Ä¢ This tool is provided "as-is" for research and evaluation purposes only.</p>
    
    <p>‚Ä¢ Results should be verified by qualified professionals before making any clinical or policy decisions.</p>
    
    <p>‚Ä¢ We are not liable for any misuse, misinterpretation, or consequences arising from the use of this platform.</p>
    
    <p>‚Ä¢ No warranty is provided regarding accuracy, completeness, or fitness for any particular purpose.</p>
    
    <div class="version-info">
      <strong>Algorithm Compatibility:</strong>
      <ul>
        <li><strong>InterVA-5:</strong> WHO 2016 v1.5.1</li>
        <li><strong>InterVA-6:</strong> WHO 2022 v01.01</li>
      </ul>
    </div>
    
    <p style="margin-top: 15px; font-size: 11px; opacity: 0.8;">¬© 2025 CCVA Processing System. All rights reserved.</p>
  </div>
  
  </div>

  <script>
    // Configuration - change this to your backend URL
    const API_BASE_URL = window.location.origin; // Uses same domain as the page
    const CHUNK_SIZE = 5 * 1024 * 1024; // 5MB chunks
    
    // State management
    let uploadedData = null;
    let resultBlob = null;
    let currentSessionId = null;
    let eventSource = null;
    let detectedWhoVersion = null;
    let isLoading = false;
    let startTime = null;
    let timerInterval = null;
    let currentAlgorithm = null; // Store current algorithm for CSMF check
    
    // DOM elements
    const fileInput = document.getElementById('fileInput');
    const fileButton = document.getElementById('fileButton');
    const fileInfo = document.getElementById('fileInfo');
    const runBtn = document.getElementById('runBtn');
    const cancelBtn = document.getElementById('cancelBtn');
    const algorithmSelect = document.getElementById('algorithmSelect');
    const whoVersionSelect = document.getElementById('whoVersionSelect');
    const outputBox = document.getElementById('outputBox');
    const downloadLink = document.getElementById('downloadLink');
    const progressSection = document.getElementById('progressSection');
    const progressFill = document.getElementById('progressFill');
    const progressPercent = document.getElementById('progressPercent');
    const progressStatus = document.getElementById('progressStatus');
    const timeElapsed = document.getElementById('timeElapsed');
    const csmfSection = document.getElementById('csmfSection');
    const barChart = document.getElementById('barChart');

    // File input change handler - auto-load in background
    fileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (file) {
        if (!file.name.endsWith('.csv')) {
          fileInfo.textContent = '‚ùå Please select a valid CSV file';
          fileInfo.style.color = '#dc3545';
          fileButton.textContent = 'Choose CSV File';
          uploadedData = null;
          runBtn.disabled = true;
          return;
        }

        // Update button text to show filename
        const shortName = file.name.length > 20 ? file.name.substring(0, 17) + '...' : file.name;
        fileButton.textContent = `üìÑ ${shortName}`;
        
        // Auto-load in background
        fileInfo.textContent = `Loading ${file.name}...`;
        fileInfo.style.color = '#007bff';
        
        uploadedData = null;
        runBtn.disabled = true;
        downloadLink.classList.remove('active');
        resetOutput();
        csmfSection.classList.remove('active');
        
        await loadCSVData(file);
      }
    });

    // WHO version select change handler - suggest algorithm but allow override
    whoVersionSelect.addEventListener('change', () => {
      const whoVersion = whoVersionSelect.value;
      
      if (whoVersion === '2016WHOv151') {
        // WHO 2016 recommended with InterVA-5
        algorithmSelect.value = 'InterVA-5';
        addLogMessage('‚Ñπ WHO 2016 ‚Üí InterVA-5 (recommended)');
      } else if (whoVersion === '2022WHOv0101') {
        // WHO 2022 recommended with InterVA-6
        algorithmSelect.value = 'InterVA-6';
        addLogMessage('‚Ñπ WHO 2022 ‚Üí InterVA-6 (recommended)');
      }
    });

    // Run button
    runBtn.addEventListener('click', async () => {
      const algorithm = algorithmSelect.value;
      const whoVersion = whoVersionSelect.value;

      await processDataWithChunking(algorithm, whoVersion);
    });

    // Cancel button - stops current processing
    cancelBtn.addEventListener('click', async () => {
      if (currentSessionId) {
        try {
          addLogMessage('‚Üí Cancelling operation...', 'error');
          
          // Send cancel request to backend
          const response = await fetch(`${API_BASE_URL}/cancel/${currentSessionId}`, {
            method: 'POST'
          });

          if (response.ok) {
            addLogMessage('‚úì Cancellation request sent to server', 'error');
          }
          
          // Close SSE connection
          closeSSE();
          
          // Update UI
          addLogMessage('‚úì Operation cancelled by user', 'error');
          setProgress(0, 'Cancelled');
          progressSection.classList.remove('active');
          
          // Stop timer
          stopTimer();
          
          // Reset buttons
          cancelBtn.disabled = true;
          cancelBtn.style.display = 'none';
          runBtn.disabled = false;
          
          // Clear session
          currentSessionId = null;
          
        } catch (error) {
          console.error('Cancel error:', error);
          addLogMessage(`‚ùå Cancel failed: ${error.message}`, 'error');
        }
      }
    });

    // Download link
    downloadLink.addEventListener('click', () => {
      if (resultBlob) {
        const url = URL.createObjectURL(resultBlob);
        const a = document.createElement('a');
        a.href = url;
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
        a.download = `interva_results_${timestamp}.csv`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        addLogMessage('File downloaded successfully!');
      }
    });

    // Load CSV data
    async function loadCSVData(file) {
      try {
        isLoading = true;
        runBtn.disabled = true;
        
        addLogMessage('‚Üí Reading CSV file...');
        
        const text = await file.text();
        addLogMessage('‚úì File read into memory');
        
        const lines = text.split('\n').filter(line => line.trim());
        
        if (lines.length < 2) {
          throw new Error('CSV file must have at least a header row and one data row');
        }

        addLogMessage(`‚Üí Found ${lines.length} lines`);

        // Parse CSV properly (handles quoted fields)
        const csvData = lines.map(line => parseCSVLine(line));

        addLogMessage(`‚úì Parsed into ${csvData[0].length} columns`);
        
        uploadedData = csvData;
        
        // Try to detect WHO version from headers
        const headers = csvData[0].map(h => h.toLowerCase().trim());
        detectedWhoVersion = detectWHOVersion(headers);
        
        if (detectedWhoVersion) {
          whoVersionSelect.value = detectedWhoVersion;
          
          // Auto-select recommended algorithm based on WHO version
          if (detectedWhoVersion === '2016WHOv151') {
            algorithmSelect.value = 'InterVA-5';
            addLogMessage(`‚úì Detected WHO 2016 ‚Üí InterVA-5 (recommended)`);
          } else if (detectedWhoVersion === '2022WHOv0101') {
            algorithmSelect.value = 'InterVA-6';
            addLogMessage(`‚úì Detected WHO 2022 ‚Üí InterVA-6 (recommended)`);
          }
          
          fileInfo.textContent = `‚úì ${file.name} loaded (${csvData.length - 1} rows, WHO ${detectedWhoVersion.includes('2016') ? '2016' : '2022'})`;
          fileInfo.style.color = '#28a745';
        } else {
          addLogMessage('‚ö† Could not auto-detect WHO version - please select manually');
          fileInfo.textContent = `‚úì ${file.name} loaded (${csvData.length - 1} rows) - Select WHO version`;
          fileInfo.style.color = '#ff9800';
        }
        
        runBtn.disabled = false;
        
      } catch (error) {
        addLogMessage(`‚ùå Failed to load CSV: ${error.message}`, 'error');
        fileInfo.textContent = `‚ùå Error: ${error.message}`;
        fileInfo.style.color = '#dc3545';
        uploadedData = null;
      } finally {
        isLoading = false;
      }
    }

    // Detect WHO version from CSV headers
    function detectWHOVersion(headers) {
      // Create a Set for faster lookup (case-insensitive)
      const columnSet = new Set(headers.map(h => h.toLowerCase().trim()));
      
      // Define key signature variables for each version
      // These are variables that are unique to each version
      
      // 2016 signature variables (unique to WHO 2016)
      const who2016Signatures = [
        'id10077note',
        'id10077_note',
        'id10444',
        'id10445',
        'id10446',
        'id10450',
        'id10451',
        'id10453',
        'id10454',
        'id10260_check2',
        'id1036x_check'
      ];
      
      // 2022 signature variables (unique to WHO 2022)
      const who2022Signatures = [
        'language',
        'id10476_audio',
        'noteon',
        'notenarr',
        'note_s_s',
        'nmh',
        'botecrn',
        'noteccd',
        'noteend'
      ];
      
      // Count matches for each version
      let count2016 = 0;
      let count2022 = 0;
      
      for (const sig of who2016Signatures) {
        if (columnSet.has(sig.toLowerCase())) {
          count2016++;
        }
      }
      
      for (const sig of who2022Signatures) {
        if (columnSet.has(sig.toLowerCase())) {
          count2022++;
        }
      }
      
      console.log(`WHO Detection: 2016 signatures=${count2016}, 2022 signatures=${count2022}`);
      
      // Make decision based on signature matches (need at least 3 matches)
      if (count2016 > count2022 && count2016 >= 3) {
        return '2016WHOv151';
      } else if (count2022 > count2016 && count2022 >= 3) {
        return '2022WHOv0101';
      } else {
        // If still unclear, use some key discriminators
        if (columnSet.has('id10077_note')) {
          return '2016WHOv151';
        } else if (columnSet.has('language')) {
          return '2022WHOv0101';
        } else {
          return null; // unknown
        }
      }
    }

    // Process data with chunking and SSE
    async function processDataWithChunking(algorithm, whoVersion) {
      try {
        // Store algorithm globally for use in completion handler
        currentAlgorithm = algorithm;
        
        runBtn.disabled = true;
        cancelBtn.disabled = false;
        cancelBtn.style.display = 'inline-block';
        downloadLink.classList.remove('active');
        resultBlob = null;

        // Show progress section
        progressSection.classList.add('active');
        setProgress(0, 'Preparing file for upload...');
        
        // Start timer
        startTimer();
        
        outputBox.innerHTML = '';
        addLogMessage('‚Üí Converting data to CSV text');

        // Convert uploadedData back to CSV text
        const csvText = uploadedData.map(row => 
          row.map(cell => {
            // Escape quotes and wrap in quotes if contains comma or newline
            const cellStr = String(cell);
            if (cellStr.includes(',') || cellStr.includes('\n') || cellStr.includes('"')) {
              return `"${cellStr.replace(/"/g, '""')}"`;
            }
            return cellStr;
          }).join(',')
        ).join('\n');

        const fileSizeKB = (csvText.length / 1024).toFixed(2);
        addLogMessage(`‚Üí CSV size: ${fileSizeKB} KB`);

        // Generate session ID
        currentSessionId = generateSessionId();
        addLogMessage(`‚Üí Session ID: ${currentSessionId}`);

        // Connect to SSE endpoint
        await connectSSE(currentSessionId);
        await sleep(300); // Give SSE time to connect

        // Split into chunks
        const chunks = [];
        for (let i = 0; i < csvText.length; i += CHUNK_SIZE) {
          chunks.push(csvText.slice(i, i + CHUNK_SIZE));
        }

        const totalChunks = chunks.length;
        addLogMessage(`‚Üí Split into ${totalChunks} chunk(s) (${(CHUNK_SIZE / 1024 / 1024).toFixed(1)}MB each)`);

        setProgress(5, 'Starting upload...');

        // Upload chunks sequentially
        for (let i = 0; i < chunks.length; i++) {
          const chunkPayload = {
            session_id: currentSessionId,
            chunk_index: i,
            total_chunks: totalChunks,
            algorithm: algorithm,
            who_version: whoVersion,
            data: chunks[i]
          };

          const response = await fetch(`${API_BASE_URL}/upload-chunk`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(chunkPayload)
          });

          if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.detail || `Chunk upload failed: ${response.status}`);
          }

          // Update progress (5% to 30% for uploads)
          const uploadProgress = 5 + (25 * (i + 1) / totalChunks);
          setProgress(uploadProgress, `Uploading chunk ${i + 1}/${totalChunks}...`);
          addLogMessage(`‚úì Uploaded chunk ${i + 1}/${totalChunks}`);
        }

        addLogMessage(`‚úì All chunks uploaded successfully`);
        setProgress(30, 'Processing data...');
        addLogMessage(`‚Üí Backend is analyzing data with ${algorithm}...`);

        // SSE will handle the rest of the progress updates
        // The download link will be enabled when processing completes

      } catch (error) {
        console.error('Processing error:', error);
        addLogMessage(`‚ùå Error: ${error.message}`, 'error');
        setProgress(0, 'Error occurred');
        progressSection.classList.remove('active');
        stopTimer();
        closeSSE();
        resultBlob = null;
        runBtn.disabled = false;
        cancelBtn.disabled = true;
        cancelBtn.style.display = 'none';
      }
    }

    // Connect to SSE endpoint
    async function connectSSE(sessionId) {
      return new Promise((resolve, reject) => {
        closeSSE(); // Close any existing connection
        
        addLogMessage('‚Üí Connecting to server event stream...');
        
        eventSource = new EventSource(`${API_BASE_URL}/stream/${sessionId}`);
        
        eventSource.onopen = () => {
          addLogMessage('‚úì Connected to server');
          resolve();
        };
        
        eventSource.onmessage = (event) => {
          try {
            // Parse the message
            const data = JSON.parse(event.data.replace(/'/g, '"'));
            
            console.log('SSE message:', data);
            
            if (data.type === 'connected') {
              addLogMessage(data.message);
            } else if (data.type === 'chunk_received') {
              // Don't update progress here - already handled in upload loop
              // Just log the message
              // addLogMessage(`‚úì ${data.message}`);
            } else if (data.type === 'progress') {
              addLogMessage(`‚Üí ${data.message}`);
              
              // Extract percentage from message if available (e.g., "Processing: 45%")
              const percentMatch = data.message.match(/(\d+)%/);
              if (percentMatch) {
                const backendPercent = parseInt(percentMatch[1]);
                // Map backend progress (0-100%) to UI progress (30-95%)
                const uiPercent = 30 + (backendPercent * 0.65);
                setProgress(uiPercent, data.message);
              } else {
                // Gradually increase if no percentage in message
                const currentProgress = getCurrentProgress();
                if (currentProgress < 95) {
                  setProgress(Math.min(currentProgress + 3, 95), data.message);
                }
              }
            } else if (data.type === 'complete') {
              addLogMessage(`‚úì ${data.message}`, 'success');
              setProgress(100, 'Complete!');
              handleProcessingComplete(sessionId);
            } else if (data.type === 'error') {
              addLogMessage(`‚ùå ${data.message}`, 'error');
              setProgress(0, 'Error');
              progressSection.classList.remove('active');
              stopTimer();
              closeSSE();
              runBtn.disabled = false;
              cancelBtn.disabled = true;
              cancelBtn.style.display = 'none';
            }
          } catch (e) {
            console.error('Error parsing SSE message:', e, event.data);
          }
        };
        
        eventSource.onerror = (error) => {
          console.error('SSE error:', error);
          // Don't treat as error if we're completing
          if (eventSource.readyState === EventSource.CLOSED) {
            console.log('SSE connection closed');
          }
        };
      });
    }

    // Close SSE connection
    function closeSSE() {
      if (eventSource) {
        eventSource.close();
        eventSource = null;
      }
    }

    // Handle processing complete
    async function handleProcessingComplete(sessionId) {
      try {
        await sleep(300);
        
        setProgress(100, 'Preparing results...');
        addLogMessage('‚Üí Preparing results...');
        
        // Download the result
        const response = await fetch(`${API_BASE_URL}/download-result/${sessionId}`);
        
        if (!response.ok) {
          throw new Error(`Download failed: ${response.status}`);
        }
        
        resultBlob = await response.blob();
        
        addLogMessage(`‚úì Results ready (${(resultBlob.size / 1024).toFixed(2)} KB)`, 'success');
        addLogMessage('‚úì Processing complete!', 'success');
        
        downloadLink.classList.add('active');
        
        // If InterVA-5, fetch and display CSMF
        if (currentAlgorithm === 'InterVA-5') {
          await fetchAndDisplayCSMF(sessionId);
        }
        
        closeSSE();
        
        // Stop timer
        stopTimer();
        
        // Hide progress bar after a moment
        await sleep(2000);
        progressSection.classList.remove('active');
        
      } catch (error) {
        console.error('Download error:', error);
        addLogMessage(`‚ùå Failed to download: ${error.message}`, 'error');
        setProgress(0, 'Download failed');
        progressSection.classList.remove('active');
        stopTimer();
      } finally {
        runBtn.disabled = false;
        cancelBtn.disabled = true;
        cancelBtn.style.display = 'none';
      }
    }

    // Generate a unique session ID
    function generateSessionId() {
      return 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    }

    // UI Helper functions
    function setProgress(percent, statusText) {
      progressFill.style.width = Math.round(percent) + '%';
      progressPercent.textContent = Math.round(percent) + '%';
      progressStatus.textContent = statusText;
    }

    function getCurrentProgress() {
      return parseFloat(progressFill.style.width) || 0;
    }

    function addLogMessage(message, type = 'info') {
      const logDiv = document.createElement('div');
      logDiv.className = 'log-message' + (type !== 'info' ? ' ' + type : '');
      logDiv.textContent = message;
      outputBox.appendChild(logDiv);
      
      // Auto-scroll to bottom
      outputBox.scrollTop = outputBox.scrollHeight;
    }

    function resetOutput() {
      outputBox.className = 'output-box';
      outputBox.innerHTML = '<div class="status-message">Ready to process data</div>';
      progressSection.classList.remove('active');
      csmfSection.classList.remove('active');
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    // Timer functions
    function startTimer() {
      startTime = Date.now();
      timeElapsed.textContent = 'Time Elapsed: 0:00';
      
      timerInterval = setInterval(() => {
        const elapsed = Math.floor((Date.now() - startTime) / 1000);
        const minutes = Math.floor(elapsed / 60);
        const seconds = elapsed % 60;
        timeElapsed.textContent = `Time Elapsed: ${minutes}:${seconds.toString().padStart(2, '0')}`;
      }, 1000);
    }

    function stopTimer() {
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
    }

    // Fetch and display CSMF data
    async function fetchAndDisplayCSMF(sessionId) {
      try {
        addLogMessage('‚Üí Fetching CSMF data...');
        
        const response = await fetch(`${API_BASE_URL}/get-csmf/${sessionId}`);
        
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(errorData.detail || `CSMF fetch failed: ${response.status}`);
        }
        
        const csmfData = await response.json();
        
        if (csmfData && csmfData.csmf && Object.keys(csmfData.csmf).length > 0) {
          addLogMessage(`‚úì CSMF data received (${Object.keys(csmfData.csmf).length} causes)`, 'success');
          displayCSMFChart(csmfData.csmf);
        } else {
          addLogMessage('‚Ñπ No CSMF data available for this analysis');
        }
        
      } catch (error) {
        console.error('CSMF fetch error:', error);
        addLogMessage(`‚Ñπ CSMF chart not available: ${error.message}`);
      }
    }

    // Display CSMF as bar chart
    function displayCSMFChart(csmfData) {
      barChart.innerHTML = '';
      
      // Convert to array and sort by value (descending)
      const csmfArray = Object.entries(csmfData).map(([cause, value]) => ({
        cause: cause,
        value: parseFloat(value)
      }));
      
      csmfArray.sort((a, b) => b.value - a.value);
      
      if (csmfArray.length === 0) {
        barChart.innerHTML = '<div class="no-csmf-message">No CSMF data available</div>';
        return;
      }
      
      // Color palette - top cause is red, rest are various colors
      const colors = [
        '#dc3545', // Red for top cause
        '#007bff', // Blue
        '#28a745', // Green
        '#ffc107', // Yellow/Gold
        '#6f42c1', // Purple
        '#fd7e14', // Orange
        '#20c997', // Teal
        '#e83e8c', // Pink
        '#17a2b8', // Cyan
        '#6c757d'  // Gray
      ];
      
      // Find max value for scaling
      const maxValue = Math.max(...csmfArray.map(d => d.value));
      
      // Create bars
      csmfArray.forEach((data, index) => {
        const barRow = document.createElement('div');
        barRow.className = 'bar-row';
        
        const barLabel = document.createElement('div');
        barLabel.className = 'bar-label';
        barLabel.textContent = data.cause;
        barLabel.title = data.cause; // Tooltip for long names
        
        const barWrapper = document.createElement('div');
        barWrapper.className = 'bar-wrapper';
        
        const barFill = document.createElement('div');
        barFill.className = 'bar-fill';
        const percentage = (data.value / maxValue) * 100;
        barFill.style.width = '0%'; // Start at 0 for animation
        barFill.style.backgroundColor = colors[index % colors.length];
        
        const barValue = document.createElement('span');
        barValue.className = 'bar-value';
        barValue.textContent = `${(data.value * 100).toFixed(2)}%`;
        
        barFill.appendChild(barValue);
        barWrapper.appendChild(barFill);
        barRow.appendChild(barLabel);
        barRow.appendChild(barWrapper);
        barChart.appendChild(barRow);
        
        // Animate bar after a short delay
        setTimeout(() => {
          barFill.style.width = `${percentage}%`;
        }, 100 + (index * 50));
      });
      
      // Show the CSMF section
      csmfSection.classList.add('active');
    }

    // Proper CSV parsing function that handles quoted fields
    function parseCSVLine(line) {
      const result = [];
      let current = '';
      let inQuotes = false;
      
      for (let i = 0; i < line.length; i++) {
        const char = line[i];
        const nextChar = line[i + 1];
        
        if (char === '"') {
          if (inQuotes && nextChar === '"') {
            // Escaped quote
            current += '"';
            i++; // Skip next quote
          } else {
            // Toggle quotes
            inQuotes = !inQuotes;
          }
        } else if (char === ',' && !inQuotes) {
          // Field separator
          result.push(current.trim());
          current = '';
        } else {
          current += char;
        }
      }
      
      // Add last field
      result.push(current.trim());
      
      return result;
    }

    // Initialize
    resetOutput();
    
    // Test connection on load
    fetch(`${API_BASE_URL}/health`)
      .then(r => r.json())
      .then(data => {
        console.log('Backend health check:', data);
        if (data.status === 'healthy') {
          fileInfo.textContent = '‚úì Connected to server - Select a CSV file to begin';
          fileInfo.style.color = '#28a745';
        }
      })
      .catch(err => {
        console.error('Backend connection failed:', err);
        fileInfo.textContent = '‚ö† Cannot connect to server. Make sure backend is running.';
        fileInfo.style.color = '#dc3545';
      });
  </script>
</body>
</html>